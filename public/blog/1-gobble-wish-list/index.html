<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>A Programming Language Wishlist</title><meta name=description><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&family=Jost&display=swap" rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css rel=stylesheet><link href=/css/var.css rel=stylesheet><link href=/css/base.css rel=stylesheet><link href=/css/header.css rel=stylesheet><link href=/css/footer.css rel=stylesheet><link href=/css/post.css rel=stylesheet><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            // • rendering keys, e.g.:
            throwOnError : false
            });
        });</script><body><script>if(localStorage.getItem('theme')=='dark'){document.body.classList.add('dark-mode');}</script><header class=blur><div class=top><a class="header blog" href=/blog><i class="ri-quill-pen-line ri-2x"></i><span>Blog</span></a><a class=back href=/><i class="ri-arrow-left-s-line ri-1x"></i><span>Home</span></a><div class=icon><a aria-label=home href=/ id=go-home><i class="ri-user-6-line ri-xl"></i></a><a aria-label="rss feed" href=/blog/feed.xml><i class="ri-rss-line ri-xl"></i></a><button aria-label="dark light mode switch" id=color-toggle><i class="ri-moon-line ri-xl"></i></button><button aria-label="table of content" id=toc-toggle><i class="ri-menu-2-line ri-xl"></i></button></div></div><div id=progress-bar></div></header><div class=wrap><div class=blank></div><main><div id=top></div><article><h1>A Programming Language Wishlist</h1><div id=post-info><div class=date><span id=publish>2022-06-19</span></div><div class=tags><a class=tag href=https://marmamorphism.com/tags/concatenative><i class="ri-hashtag ri-sm"></i><span>concatenative</span></a><a class=tag href=https://marmamorphism.com/tags/design><i class="ri-hashtag ri-sm"></i><span>design</span></a></div></div><p>I've been thinking about a programming language for a while that makes the trade-offs that I prefer. The high-level overview is something like this:<ul><li>no bound variables;<li>a type system with at least dependent function types and refinement types;<li>a DSL (Domain Specific Language) system that is conducive to inspection and easy extension;<li>and efficient execution.</ul><p>Let's talk about each of these.<h2 id=no-bound-variables>No Bound Variables</h2><p>Bound variables are the heart and soul of the $\lambda$-calculus. Variables give you the ability to mark internal sharing and are pretty natural based on mathematical practice. So why get rid of them? The reason is three-fold.<p>First, when you are dealing with first-class higher-order functions the variables get in the way of efficient execution by demanding some garbage collection discipline. One choice to recover efficiency is enforced linearity (i.e. a variable can only occur once in the body), but now you're placing a seemingly arbitrary restriction on what was standard practice.<p>Second, if you want easy quotable syntax the variables complicate things. Now the users creating macros have to handle bound variables too, usually by hygienic patterns. This is the path taken by many modern macro systems.<p>Third, if you do have a robust DSL system then you can add in bound variables without much issue. To that point, why complicate the <em>core</em> system with bound variables if it can be implemented as a library feature?<h2 id=rich-type-system>Rich Type System</h2><p>The lack of dependent types in most modern languages is caused by a few things. Dependent types do not play nice with effects (e.g. non-termination, exceptions, I/O), they can complicate type checking, and your average programmer is scared of them. For a crash course in dependent function types, consider the following type: <code>Vec Nat n</code> which represents a list with <em>exactly</em> $n$ elements. This is impossible to represent in a lot of languages but pretty trivial in a language with dependent types. Together with the finite type: <code>Fin n</code> which represents a number in the range $[0, n)$ you have a safe, optimization friendly way to access arrays:<pre class=language-rust data-lang=rust style=background-color:#282a36;color:#f8f8f2;><code class=language-rust data-lang=rust><span>    </span><span style=font-style:italic;color:#8be9fd;>let</span><span> array : </span><span style=font-style:italic;color:#66d9ef;>Vec</span><span> Nat n </span><span style=color:#ff79c6;>= ...</span><span>
</span><span>    </span><span style=font-style:italic;color:#8be9fd;>let</span><span> index : Fin n </span><span style=color:#ff79c6;>= ...</span><span>
</span><span>    array[index] </span><span style=color:#6272a4;>// no bounds checks necessary</span><span>
</span></code></pre><p>Refinement types also seem like a pretty necessary feature, but they are more exotic. Languages like <a rel="nofollow noreferrer" href=https://github.com/agda/agda>Agda</a> and <a rel="nofollow noreferrer" href=https://coq.inria.fr/>Coq</a> don't have refinement types in the sense I mean, but <a rel="nofollow noreferrer" href=https://www.fstar-lang.org/>F*</a> does. A simple refinement type is the type of even numbers:<p>$$\texttt{Even} = \{ n: \mathbb{N}\ |\ n = 0 \mod 2 \}$$<p>Critically, there should be a trivial cast (i.e. an identity function) that forgets the refinements and produces a natural number. This is not the same as wrapping up a natural number in a dependent pair where the second component is a proof the first is even. You also likely want some definitional equalities, such as $2 : \texttt{Even} \equiv 2 : \mathbb{N}$. These choices cause you to have an extrinsic type theory (i.e. a given term can have more than one type).<p>Another critical requirement is that the type system supports axioms. In particular, recursive types with the added <em>axiom</em> that they are well-founded. This is in contrast to most systems which include syntactic requirements like strict positivity. Although, in plenty of other systems, like <a rel="nofollow noreferrer" href=https://www.idris-lang.org/>Idris</a>, a type-in-type discipline is used which allows general recursive types (and thus inconsistency).<p>The point here is that recursive types should be an <em>unsafe</em> feature that demands some meta-obligations of the programmer, not unlike unsafe code in <a rel="nofollow noreferrer" href=https://www.rust-lang.org/>Rust</a>, or "trust me" annotations on recursive functions in Agda or Idris. However, these "trust me" annotations are not spelled out in the formal core theory. They are tacked on, and the burden is shifted to the user to make sure they do things right.<p>Coq and Rust do the best job, in my opinion, of giving the user guidelines of when axioms or meta-obligations are allowed. Coq has an entire <a rel="nofollow noreferrer" href=https://github.com/coq/coq/wiki/CoqAndAxioms>wiki-page</a> about axioms that you can expect to not break your development. Rust has some <a rel="nofollow noreferrer" href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html>explicit rules</a> about what expectations are in place for unsafe code. However, it should also be noted how difficult it is to do <a rel="nofollow noreferrer" href=https://gankra.github.io/blah/fix-rust-pointers/>pointer cast in unsafe Rust correctly</a>! In this scenario, the meta-obligations are too strong.<p>Regardless, the trade-off is a powerful and necessary one. Give the user an escape hatch with a well documented set of meta-obligations so that they can express themselves in code to the fullest extent possible. Moreover, deciding that a recursive function is well-founded is a daily occurrence for programmers and it is often trivially terminating from the perspective of the programmer (but often not trivially terminating from the perspective of syntactic criterion used in Coq or Agda!)<h2 id=powerful-dsl-system>Powerful DSL System</h2><p>Let's be honest, there is only one game in town when it comes to reasonable DSLs and that is <a rel="nofollow noreferrer" href=https://racket-lang.org/>Racket</a>. I don't have much experience with Racket and think there is a lot to learn there. Also, I fundamentally agree that allowing the user to construct DSLs is important if you want a language to help a user express domain knowledge. Yet, macro systems are a complete disaster. The greatest failure of Lisp is perhaps its macro system. Macros in Lisp are so powerful that they make code written by a programmer completely incomprehensible. Somehow, they are also too weak to express the kinds of syntactic constructs that are more natural on pen-and-paper. This is likely why Racket is a thing at all, if Lisp solved DSLs at the onset there would be no Racket.<p>What is needed of a good DSL system? I think the following things:<ul><li>easy inspection via the core syntax both with a debug representation and the actual representation;<li>easy construction by well-known grammar definitions;<li>and easy combination and interoperability between DSLs.</ul><p>To inspect a DSL I propose the requirement that any span of a DSL can be independently transformed into core syntax. For example, consider the following DSL code:<pre class=language-rust data-lang=rust style=background-color:#282a36;color:#f8f8f2;><code class=language-rust data-lang=rust><span>    </span><span style=font-style:italic;color:#8be9fd;>fn </span><span style=color:#50fa7b;>quadratic</span><span>(</span><span style=font-style:italic;color:#ffb86c;>a</span><span>: </span><span style=font-style:italic;color:#8be9fd;>usize</span><span>, </span><span style=font-style:italic;color:#ffb86c;>b</span><span>: </span><span style=font-style:italic;color:#8be9fd;>usize</span><span>, </span><span style=font-style:italic;color:#ffb86c;>c</span><span>: </span><span style=font-style:italic;color:#8be9fd;>usize</span><span>) </span><span style=color:#ff79c6;>-> </span><span style=font-style:italic;color:#8be9fd;>usize </span><span style=color:#ffffff;>{</span><span>
</span><span>        a</span><span style=color:#ff79c6;>*</span><span>a </span><span style=color:#ff79c6;>+</span><span> b</span><span style=color:#ff79c6;>*</span><span>b </span><span style=color:#ff79c6;>+</span><span> c</span><span>
</span><span>    </span><span style=color:#ffffff;>}</span><span>
</span></code></pre><p>In case you missed the implication, a language without bound variables basically ends up looking like a variation on <a rel="nofollow noreferrer" href=https://www.forth.com/forth/>Forth</a>. Here is how I imagine the above representation being encoded:<pre class=language-rust data-lang=rust style=background-color:#282a36;color:#f8f8f2;><code class=language-rust data-lang=rust><span>    [</span><span>
</span><span>        </span><span style=color:#6272a4;>// stack starts as [c, b, a]</span><span>
</span><span>        dup </span><span style=color:#ff79c6;>*       </span><span style=color:#6272a4;>// compute a^2</span><span>
</span><span>        swap dup </span><span style=color:#ff79c6;>*  </span><span style=color:#6272a4;>// compute b^2</span><span>
</span><span>        </span><span style=color:#ff79c6;>+ +         </span><span style=color:#6272a4;>// compute a^2 + b^2 + c</span><span>
</span><span>    ]</span><span>
</span><span>    [quadratic]</span><span>
</span><span>    define</span><span>
</span></code></pre><p>Where the syntax <code>[...]</code> is a <em>quote</em> inspired by <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Joy_(programming_language)>Joy</a>. Now, if a user selects the <code>b*b</code> span in the DSL, they should be able to see that it maps to <code>swap dup *</code> code in the core syntax. It might not be the easiest to comprehend Forth-style (or really Joy-style) syntax for most programmers. Indeed, it is likely better to describe it as a high-level assembler, but the benefits are that it does always make sense, even if it takes some effort to figure out what. In contrast, someone's invented notation with no documentation may <em>never</em> make sense.<h2 id=efficient-execution>Efficient Execution</h2><p>A concatenative programming language, which is ultimately what I am describing, yields to fairly obvious efficient execution by way of a linear type system. The real issue only arises with quotes which are the replacement for higher-order functions. For this, the proposed fix is to require that quotes are not data unless boxed or otherwise hidden behind a pointer. Ultimately, this pushes the garbage collection duties to the user, they have to construct smart pointers like reference counting.<p>However, that is the main design principle behind all of this. Keep the core language as simple as possible without sacrificing expressibility or power. Push as much as possible into libraries. As the design grows this core principle will remain.</article></main><aside class=blur><nav><ul><li><a class=toc-h2 href=#no-bound-variables>No Bound Variables</a><li><a class=toc-h2 href=#rich-type-system>Rich Type System</a><li><a class=toc-h2 href=#powerful-dsl-system>Powerful DSL System</a><li><a class=toc-h2 href=#efficient-execution>Efficient Execution</a></ul></nav><a aria-label="back to top" href=#top id=back-to-top><i class="ri-arrow-up-s-line ri-2x"></i></a></aside></div><footer><div class=copyright>Copyright © 2022 Andrew Marmaduke. All rights reserved.</div><div class=credits><span>Powered by <a rel="noreferrer noopener" href=https://www.getzola.org/ target=_blank>Zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>Serene</a></span></div></footer><script src=/js/dark.js></script><script src=/js/toc.js></script><script src=/js/progress.js></script><script src=/js/lightense.min.js></script><script src=/js/img.js></script>